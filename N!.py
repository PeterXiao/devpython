__author__ = 'Peter xiao'
'''
   阶乘函数的定义是：
N! = factorial(N) = 1 * 2 * 3 * ... * N

那么可以用这种方法来看阶乘函数：
factorial(N) = N!
             = N * (N - 1)!
             = N * (N - 1) * (N - 2)!
             = N * (N - 1) * (N - 2) * ... * 3 * 2 * 1
             = N * factorial(N - 1)


'''
def factorial(x):
    if  x <= 1:
        return  1
    return x * factorial(x-1)
print(factorial(10))

'''
（1）递归就是在过程或函数里调用自身；
（2）在使用递归策略时，必须有一个明确的递归结束条件，称为递归出口。

递归算法一般用于解决三类问题：
（1）数据的定义是按递归定义的。（比如Fibonacci函数）
（2）问题解法按递归算法实现。（回溯）
（3）数据的结构形式是按递归定义的。（比如树的遍历，图的搜索） 　　

递归的缺点：递归算法解题的运行效率较低。在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。

每一个递归程序都遵循相同的基本步骤：
1.初始化算法。递归程序通常需要一个开始时使用的种子值（seed value）。要完成此任务，可以向函数传递参数，或者提供一个入口函数，这个函数是非递归的，但可以为递归计算设置种子值。
2.检查要处理的当前值是否已经与基线条件相匹配（base case）。如果匹配，则进行处理并返回值。
3.使用更小的或更简单的子问题（或多个子问题）来重新定义答案。
4.对子问题运行算法。
5.将结果合并入答案的表达式。
6.返回结果。

基线条件（base case）。基线条件是递归程序的最底层位置，在此位置时没有必要再进行操作，可以直接返回一个结果。所有递归程序都必须至少拥有一个基线条件，而且必须确保它们最终会达到某个基线条件；否则，程序将永远运行下去，直到程序缺少内存或者栈空间。

自己总结了一下，要写一个递归的程序，需要这样做：
1.一个基线条件。请在递归函数的一开始就处理这个基线条件。
2.一系列的规则，使对递归函数的每次调用都趋进于直至达到这个基线条件。


'''